package seed

import (
	"PQC-Master-Thesis/internal/common"
	"encoding/binary"
	"fmt"
	"math"

	"golang.org/x/crypto/sha3"
)

type TreeParams struct {
	NPL         []int // Nodes per level
	LPL         []int // Leaves per level
	Off         []int // Offsets for parent/child computation
	LSI         []int // Leaves start indices
	NCL         []int // Number of consecutive leaves
	TN          int   // Nodes to store
	Total_nodes int   // Total number of nodes in tree
	Subroots    int   // Number of subroots
}

func sum(slice []int) int {
	total := 0
	for _, v := range slice {
		total += v
	}
	return total
}

func GetTreeParams(schemeType, variant string, level int) (TreeParams, error) {
	// Magic Constants generated by the CROSS team using: Available at parameters.h on Github
	params := TreeParams{}
	if level == 1 && variant == "RSDP" && schemeType == "fast" {
		params.Off = []int{0, 0, 0, 0, 0, 2, 2, 58, 58}
		params.NPL = []int{1, 2, 4, 8, 16, 30, 60, 64, 128}
		params.LPL = []int{0, 0, 0, 0, 1, 0, 28, 0, 128}
		params.LSI = []int{185, 93, 30}
		params.NCL = []int{128, 28, 1}
		params.TN = 82
		params.Subroots = 3
	} else if level == 1 && variant == "RSDP" && schemeType == "balanced" {
		params.Off = []int{0, 0, 0, 0, 0, 0, 0, 0, 0}
		params.NPL = []int{1, 2, 4, 8, 16, 32, 64, 128, 256}
		params.LPL = []int{0, 0, 0, 0, 0, 0, 0, 0, 256}
		params.LSI = []int{255}
		params.NCL = []int{256}
		params.TN = 108
		params.Subroots = 1
	} else if level == 1 && variant == "RSDP" && schemeType == "small" {
		params.Off = []int{0, 0, 0, 0, 0, 16, 16, 16, 16, 16, 16}
		params.NPL = []int{1, 2, 4, 8, 16, 16, 32, 64, 128, 256, 512}
		params.LPL = []int{0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 512}
		params.LSI = []int{527, 23}
		params.NCL = []int{512, 8}
		params.TN = 129
		params.Subroots = 2
	} else if level == 3 && variant == "RSDP" && schemeType == "fast" {
		params.Off = []int{0, 0, 0, 0, 0, 0, 0, 2, 30}
		params.NPL = []int{1, 2, 4, 8, 16, 32, 64, 126, 224}
		params.LPL = []int{0, 0, 0, 0, 0, 0, 1, 14, 224}
		params.LSI = []int{253, 239, 126}
		params.NCL = []int{224, 14, 1}
		params.TN = 125
		params.Subroots = 3
		params.Total_nodes = sum(params.NPL)
	} else if level == 3 && variant == "RSDP" && schemeType == "balanced" {
		params.Off = []int{0, 0, 0, 0, 0, 0, 0, 0, 0, 256}
		params.NPL = []int{1, 2, 4, 8, 16, 32, 64, 128, 256, 256}
		params.LPL = []int{0, 0, 0, 0, 0, 0, 0, 0, 128, 256}
		params.LSI = []int{511, 383}
		params.NCL = []int{256, 128}
		params.TN = 165
		params.Subroots = 2
	} else if level == 3 && variant == "RSDP" && schemeType == "small" {
		params.Off = []int{0, 0, 0, 0, 0, 8, 8, 8, 8, 136, 136}
		//params.Off = []int{0, 0, 0, 0, 0, 8, 16, 32, 64, 200, 400}
		params.NPL = []int{1, 2, 4, 8, 16, 24, 48, 96, 192, 256, 512}
		params.LPL = []int{0, 0, 0, 0, 4, 0, 0, 0, 64, 0, 512}
		params.LSI = []int{647, 327, 27}
		params.NCL = []int{512, 64, 4}
		params.TN = 184
		params.Subroots = 3
	} else if level == 5 && variant == "RSDP" && schemeType == "fast" {
		params.Off = []int{0, 0, 0, 2, 2, 2, 2, 2, 2, 130}
		params.NPL = []int{1, 2, 4, 6, 12, 24, 48, 96, 192, 256}
		params.LPL = []int{0, 0, 1, 0, 0, 0, 0, 0, 64, 256}
		params.LSI = []int{385, 321, 6}
		params.NCL = []int{256, 64, 1}
		params.TN = 167
		params.Subroots = 3
	} else if level == 5 && variant == "RSDP" && schemeType == "balanced" {
		params.Off = []int{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
		params.NPL = []int{1, 2, 4, 8, 16, 32, 64, 128, 256, 512}
		params.LPL = []int{0, 0, 0, 0, 0, 0, 0, 0, 0, 512}
		params.LSI = []int{511}
		params.NCL = []int{512}
		params.TN = 220
		params.Subroots = 1
	} else if level == 5 && variant == "RSDP" && schemeType == "small" {
		params.Off = []int{0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 128}
		params.NPL = []int{1, 2, 4, 8, 16, 32, 64, 128, 256, 384, 768}
		params.LPL = []int{0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 768}
		params.LSI = []int{895, 447}
		params.NCL = []int{768, 64}
		params.TN = 251
		params.Subroots = 2
	} else if level == 1 && variant == "RSDP-G" && schemeType == "fast" {
		params.Off = []int{0, 0, 0, 0, 2, 6, 6, 38, 38}
		params.NPL = []int{1, 2, 4, 8, 14, 24, 48, 64, 128}
		params.LPL = []int{0, 0, 0, 1, 2, 0, 16, 0, 128}
		params.LSI = []int{165, 85, 27, 14}
		params.NCL = []int{128, 16, 2, 1}
		params.TN = 76
		params.Subroots = 4
	} else if level == 1 && variant == "RSDP-G" && schemeType == "balanced" {
		params.Off = []int{0, 0, 0, 0, 0, 0, 0, 0, 0}
		params.NPL = []int{1, 2, 4, 8, 16, 32, 64, 128, 256}
		params.LPL = []int{0, 0, 0, 0, 0, 0, 0, 0, 256}
		params.LSI = []int{255}
		params.NCL = []int{256}
		params.TN = 101
		params.Subroots = 1
	} else if level == 1 && variant == "RSDP-G" && schemeType == "small" {
		params.Off = []int{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
		params.NPL = []int{1, 2, 4, 8, 16, 32, 64, 128, 256, 512}
		params.LPL = []int{0, 0, 0, 0, 0, 0, 0, 0, 0, 512}
		params.LSI = []int{511}
		params.NCL = []int{512}
		params.TN = 117
		params.Subroots = 1
	} else if level == 3 && variant == "RSDP-G" && schemeType == "fast" {
		params.Off = []int{0, 0, 0, 0, 0, 0, 0, 0, 64}
		params.NPL = []int{1, 2, 4, 8, 16, 32, 64, 128, 192}
		params.LPL = []int{0, 0, 0, 0, 0, 0, 0, 32, 192}
		params.LSI = []int{255, 223}
		params.NCL = []int{192, 32}
		params.TN = 119
		params.Subroots = 2
	} else if level == 3 && variant == "RSDP-G" && schemeType == "balanced" {
		params.Off = []int{0, 0, 0, 0, 0, 8, 24, 24, 24, 24}
		params.NPL = []int{1, 2, 4, 8, 16, 24, 32, 64, 128, 256}
		params.LPL = []int{0, 0, 0, 0, 4, 8, 0, 0, 0, 256}
		params.LSI = []int{279, 47, 27}
		params.NCL = []int{256, 8, 4}
		params.TN = 138
		params.Subroots = 3
	} else if level == 3 && variant == "RSDP-G" && schemeType == "small" {
		params.Off = []int{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
		params.NPL = []int{1, 2, 4, 8, 16, 32, 64, 128, 256, 512}
		params.LPL = []int{0, 0, 0, 0, 0, 0, 0, 0, 0, 512}
		params.LSI = []int{511}
		params.NCL = []int{512}
		params.TN = 165
		params.Subroots = 1
	} else if level == 5 && variant == "RSDP-G" && schemeType == "fast" {
		params.Off = []int{0, 0, 0, 0, 0, 0, 8, 24, 88, 88}
		params.NPL = []int{1, 2, 4, 8, 16, 32, 56, 96, 128, 256}
		params.LPL = []int{0, 0, 0, 0, 0, 4, 8, 32, 0, 256}
		params.LSI = []int{343, 183, 111, 59}
		params.NCL = []int{256, 32, 8, 4}
		params.TN = 153
		params.Subroots = 4
	} else if level == 5 && variant == "RSDP-G" && schemeType == "balanced" {
		params.Off = []int{0, 0, 0, 0, 0, 0, 8, 8, 8, 200}
		params.NPL = []int{1, 2, 4, 8, 16, 32, 56, 112, 224, 256}
		params.LPL = []int{0, 0, 0, 0, 0, 4, 0, 0, 96, 256}
		params.LSI = []int{455, 359, 59}
		params.NCL = []int{256, 96, 4}
		params.TN = 185
		params.Subroots = 3
	} else if level == 5 && variant == "RSDP-G" && schemeType == "small" {
		params.Off = []int{0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 260}
		params.NPL = []int{1, 2, 4, 8, 12, 24, 48, 96, 192, 384, 512}
		params.LPL = []int{0, 0, 0, 2, 0, 0, 0, 0, 0, 128, 512}
		params.LSI = []int{771, 643, 13}
		params.NCL = []int{512, 128, 2}
		params.TN = 220
		params.Subroots = 3
	} else {
		return TreeParams{}, fmt.Errorf("invalid parameters for tree structures")
	}
	params.Total_nodes = sum(params.NPL)
	return params, nil
}

func LeftChild(node_index, level int, tree_params TreeParams) int {
	return (2*node_index + 1) - tree_params.Off[level]
}
func Parent(node_index int) int {
	if node_index%2 == 1 {
		return (node_index - 1) / 2 //+ (tree_params.Off[level-1] / 2)
	} else {
		return (node_index - 2) / 2 //+ (tree_params.Off[level-1] / 2)

	}

}
func ParentIndex(index int) []byte {
	data := make([]byte, 2)
	// Convert to little-endian
	binary.LittleEndian.PutUint16(data, uint16(index))
	return data
}

func Leaves(tree [][]byte, tree_params TreeParams) [][]byte {
	result := [][]byte{}
	for i := 0; i < len(tree_params.LSI); i++ {
		index := tree_params.LSI[i]
		for j := 0; j < tree_params.NCL[i]; j++ {
			result = append(result, tree[index+j])
		}
	}
	return result
}

func BuildTree(schemeType string, seed, salt []byte, proto_params common.ProtocolData, tree_params TreeParams) ([][]byte, error) {
	if schemeType == "balanced" || schemeType == "small" {
		T := make([][]byte, tree_params.Total_nodes)
		T[0] = seed
		start_node := 0
		for level := 0; level <= int(math.Ceil(math.Log2(float64(proto_params.T)))-1); level++ {
			for i := 0; i <= tree_params.NPL[level]-tree_params.LPL[level]-1; i++ {
				parent := start_node + i
				left_child := LeftChild(parent, level, tree_params)
				right_child := left_child + 1
				// Expand parent seed, salt and parent index
				hash := make([]byte, (2*proto_params.Lambda)/8)
				sha3.ShakeSum128(hash, append(append(T[parent], salt...), ParentIndex(parent)...))
				T[left_child] = hash[:proto_params.Lambda/8]
				T[right_child] = hash[proto_params.Lambda/8:]
			}
			start_node += tree_params.NPL[level]

		}
		return T, nil
	} else if schemeType == "fast" {
		T := make([][]byte, tree_params.Total_nodes)
		T[0] = seed
		hash := make([]byte, (4*proto_params.Lambda)/8)
		sha3.ShakeSum128(hash, append(append(T[0], salt...), ParentIndex(0)...))
		for i := 1; i <= 4; i++ {
			T[i] = hash[(i-1)*proto_params.Lambda/8 : i*proto_params.Lambda/8]
		}
		children := make([]int, 4)
		if proto_params.T%4 == 0 {
			for i := 0; i < len(children); i++ {
				children[i] = int(math.Floor(float64(proto_params.T) / 4))
			}
		} else if proto_params.T%4 == 1 {
			for i := 0; i < len(children); i++ {
				if i == 0 {
					children[i] = int(math.Floor(float64(proto_params.T)/4)) + 1
				} else {
					children[i] = int(math.Floor(float64(proto_params.T) / 4))
				}
			}
		} else if proto_params.T%4 == 2 {
			for i := 0; i < len(children); i++ {
				if i == 0 || i == 1 {
					children[i] = int(math.Floor(float64(proto_params.T)/4)) + 1
				} else {
					children[i] = int(math.Floor(float64(proto_params.T) / 4))
				}
			}
		} else if proto_params.T%4 == 3 {
			for i := 0; i < len(children); i++ {
				if i == 0 || i == 1 || i == 2 {
					children[i] = int(math.Floor(float64(proto_params.T)/4)) + 1
				} else {
					children[i] = int(math.Floor(float64(proto_params.T) / 4))
				}
			}
		}
		result := [][]byte{}
		for i := 0; i <= 3; i++ {
			hash := make([]byte, (children[i]*proto_params.Lambda)/8)
			sha3.ShakeSum128(hash, append(append(T[i+1], salt...), ParentIndex(i+1)...))
			for j := 0; j < children[i]; j++ {
				result = append(result, hash[j*proto_params.Lambda/8:(j+1)*proto_params.Lambda/8])
			}
		}
		return result, nil
	} else {
		return nil, fmt.Errorf("Scheme type not supported only balanced, small and fast are supported")
	}
}
func SeedLeaves(schemeType string, seed, salt []byte, proto_params common.ProtocolData, tree_params TreeParams) ([][]byte, error) {
	if schemeType == "balanced" || schemeType == "small" {
		T, err := BuildTree(schemeType, seed, salt, proto_params, tree_params)
		if err != nil {
			return nil, fmt.Errorf("Error: %s", err)
		}
		return Leaves(T, tree_params), nil
	} else if schemeType == "fast" {
		return BuildTree(schemeType, seed, salt, proto_params, tree_params)
	} else {
		return nil, fmt.Errorf("Scheme type not supported only balanced, small and fast are supported")
	}
}

// List of all leaf indices for the tree
func LeafSet(tree_params TreeParams) []int {
	var result []int
	for i := 0; i < len(tree_params.LSI); i++ {
		count := tree_params.NCL[i]
		start := tree_params.LSI[i]
		for j := 0; j < count; j++ {
			result = append(result, start+j)
		}
	}
	/*for i, start := range tree_params.LSI {
		count := tree_params.NCL[i]
		for j := 0; j < count; j++ {
			result = append(result, start+j)
		}
	}*/
	return result
}

func GetLevelOfNode(node_index int, tree_params TreeParams) int {
	acc := node_index
	for i := 0; i < len(tree_params.NPL); i++ {
		acc -= tree_params.NPL[i]
		if acc <= 0 {
			return i
		}
	}
	return -1
}
func ComputeNodesToPublish(chall_2 []bool, tree_params TreeParams) []int {
	result := make([]bool, tree_params.Total_nodes)
	ctr := 0
	for i := 0; i < len(tree_params.LSI); i++ {
		for j := 0; j < tree_params.NCL[i]; j++ {
			if chall_2[ctr] {
				result[tree_params.LSI[i]+j] = chall_2[ctr]
			}
			ctr++
		}
	}
	leafset := LeafSet(tree_params)
	for i := len(result) - 1; i >= 0; i-- {
		level := GetLevelOfNode(i, tree_params)
		if !contains(leafset, i) && result[LeftChild(i, level, tree_params)] && result[LeftChild(i, level, tree_params)+1] {
			result[i] = true
			result[LeftChild(i, level, tree_params)] = false
			result[LeftChild(i, level, tree_params)+1] = false
		}
	}
	path := []int{}
	for i := 0; i < len(result); i++ {
		if result[i] {
			path = append(path, i)
		}
	}
	return path
}

func SeedPath(schemeType string, seed, salt []byte, chall_2 []bool, proto_params common.ProtocolData, tree_params TreeParams) ([][]byte, error) {
	if schemeType == "balanced" || schemeType == "small" {
		T, err := BuildTree(schemeType, seed, salt, proto_params, tree_params)
		if err != nil {
			return nil, err
		}
		path := ComputeNodesToPublish(chall_2, tree_params)
		//fmt.Println("Path:", path)
		seedPath := [][]byte{}
		for i := 0; i < len(path); i++ {
			/*if path[i] == 510 {
				fmt.Println("Within func:", T[path[i]])
			}*/
			seedPath = append(seedPath, T[path[i]])
		}
		return seedPath, nil
	} else if schemeType == "fast" {
		leaves, err := SeedLeaves(schemeType, seed, salt, proto_params, tree_params)
		if err != nil {
			return nil, err
		}
		var result [][]byte
		for i := 0; i < len(chall_2); i++ {
			if chall_2[i] {
				result = append(result, leaves[i])
			}
		}
		return result, nil
	} else {
		return nil, fmt.Errorf("Scheme type not supported only balanced, small and fast are supported")
	}
}
func contains(slice []int, elem int) bool {
	for _, v := range slice {
		if v == elem {
			return true
		}
	}
	return false
}

func CountTrue(chall []bool) int {
	count := 0
	for _, val := range chall {
		if val {
			count++
		}
	}
	return count
}

func RebuildLeaves(schemeType string, path [][]byte, salt []byte, chall_2 []bool, proto_params common.ProtocolData, tree_params TreeParams) ([][]byte, error) {
	if schemeType == "balanced" || schemeType == "small" {
		T_prime := ComputeNodesToPublish(chall_2, tree_params)
		T := make([][]byte, tree_params.Total_nodes)
		start_node := 0
		pub_nodes := 0
		for level := 1; level <= int(math.Ceil(math.Log2(float64(proto_params.T)))); level++ {
			for i := 0; i <= tree_params.NPL[level]; i++ {
				node := start_node + i
				parent := Parent(node)
				left_child := LeftChild(node, level, tree_params)
				right_child := left_child + 1
				if contains(T_prime, node) && !contains(T_prime, parent) {
					T[node] = path[pub_nodes]
					pub_nodes++
				}
				if contains(T_prime, node) && i < tree_params.NPL[level]-tree_params.LPL[level] {
					hash := make([]byte, (2*proto_params.Lambda)/8)
					sha3.ShakeSum128(hash, append(append(T[node], salt...), ParentIndex(node)...))
					T[left_child] = hash[:proto_params.Lambda/8]
					T[right_child] = hash[proto_params.Lambda/8:]
					T_prime = append(T_prime, left_child)
					T_prime = append(T_prime, right_child)
					//fmt.Println("T_prime: ", T_prime)
				}
				//fmt.Println("T_prime: ", T_prime)
			}
			start_node += tree_params.NPL[level]
		}
		result := [][]byte{}
		leaves := Leaves(T, tree_params)
		for i := 0; i < len(leaves); i++ {
			if chall_2[i] {
				/*if leaves[i] == nil {
					return nil, fmt.Errorf("Leaf %d is nil", i)
				}*/
				result = append(result, leaves[i])
			}
		}

		return result, nil
	} else if schemeType == "fast" {
		// Verify path length and chall_2
		if len(path) != CountTrue(chall_2) {
			return nil, fmt.Errorf("Path length and chall_2 length do not match")
		}
		return path, nil
	} else {
		return nil, fmt.Errorf("Scheme type not supported only balanced, small and fast are supported")
	}
}
