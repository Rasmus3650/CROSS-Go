package main

import (
	"PQC-Master-Thesis/internal/common"
	"encoding/binary"
	"fmt"
	"math"

	"golang.org/x/crypto/sha3"
)

type TreeParams struct {
	NPL []int // Nodes per level
	LPL []int // Leaves per level
	Off []int // Offsets for parent/child computation
	LSI []int // Leaves start indices
	NCL []int // Number of consecutive leaves
	TN  int   // Total number of nodes
}

func GetTreeParams(schemeType, variant string, level int) TreeParams {
	// Magic Constants generated by the CROSS team using: compute_derived_parameters.py, from their submission package (NOT ON GITHUB)
	params := TreeParams{}
	if level == 1 && variant == "RSDP" && schemeType == "fast" {
		params.Off = []int{0, 0, 0, 0, 0, 2, 2, 58, 58}
		params.NPL = []int{1, 2, 4, 8, 16, 30, 60, 64, 128}
		params.LPL = []int{0, 0, 0, 0, 1, 0, 28, 0, 128}
		params.LSI = []int{185, 93, 30}
		params.NCL = []int{128, 28, 1}
		params.TN = 82
	} else if level == 1 && variant == "RSDP" && schemeType == "balanced" {
		params.Off = []int{0, 0, 0, 0, 0, 0, 0, 0, 0}
		params.NPL = []int{1, 2, 4, 8, 16, 32, 64, 128, 256}
		params.LPL = []int{0, 0, 0, 0, 0, 0, 0, 0, 256}
		params.LSI = []int{255}
		params.NCL = []int{256}
		params.TN = 108
	} else if level == 1 && variant == "RSDP" && schemeType == "small" {
		params.Off = []int{0, 0, 0, 0, 0, 16, 16, 16, 16, 16, 16}
		params.NPL = []int{1, 2, 4, 8, 16, 16, 32, 64, 128, 256, 512}
		params.LPL = []int{0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 512}
		params.LSI = []int{527, 23}
		params.NCL = []int{512, 8}
		params.TN = 129
	} else if level == 3 && variant == "RSDP" && schemeType == "fast" {
		params.Off = []int{0, 0, 0, 0, 0, 0, 0, 2, 30}
		params.NPL = []int{1, 2, 4, 8, 16, 32, 64, 126, 224}
		params.LPL = []int{0, 0, 0, 0, 0, 0, 1, 14, 224}
		params.LSI = []int{253, 239, 126}
		params.NCL = []int{224, 14, 1}
		params.TN = 125
	} else if level == 3 && variant == "RSDP" && schemeType == "balanced" {
		params.Off = []int{0, 0, 0, 0, 0, 0, 0, 0, 0, 256}
		params.NPL = []int{1, 2, 4, 8, 16, 32, 64, 128, 256, 256}
		params.LPL = []int{0, 0, 0, 0, 0, 0, 0, 0, 128, 256}
		params.LSI = []int{511, 383}
		params.NCL = []int{256, 128}
		params.TN = 165
	} else if level == 3 && variant == "RSDP" && schemeType == "small" {
		params.Off = []int{0, 0, 0, 0, 0, 8, 8, 8, 8, 136, 136}
		params.NPL = []int{1, 2, 4, 8, 16, 24, 48, 96, 192, 256, 512}
		params.LPL = []int{0, 0, 0, 0, 4, 0, 0, 0, 64, 0, 512}
		params.LSI = []int{647, 327, 27}
		params.NCL = []int{512, 64, 4}
		params.TN = 184
	} else if level == 5 && variant == "RSDP" && schemeType == "fast" {
		params.Off = []int{0, 0, 0, 2, 2, 2, 2, 2, 2, 130}
		params.NPL = []int{1, 2, 4, 6, 12, 24, 48, 96, 192, 256}
		params.LPL = []int{0, 0, 1, 0, 0, 0, 0, 0, 64, 256}
		params.LSI = []int{385, 321, 6}
		params.NCL = []int{256, 64, 1}
		params.TN = 167
	} else if level == 5 && variant == "RSDP" && schemeType == "balanced" {
		params.Off = []int{0, 0, 0, 0, 0, 0, 0, 0, 0}
		params.NPL = []int{1, 2, 4, 8, 16, 32, 64, 128, 256, 512}
		params.LPL = []int{0, 0, 0, 0, 0, 0, 0, 0, 0, 512}
		params.LSI = []int{511}
		params.NCL = []int{512}
		params.TN = 220
	} else if level == 5 && variant == "RSDP" && schemeType == "small" {
		params.Off = []int{0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 128}
		params.NPL = []int{1, 2, 4, 8, 16, 32, 64, 128, 256, 384, 768}
		params.LPL = []int{0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 768}
		params.LSI = []int{895, 447}
		params.NCL = []int{768, 64}
		params.TN = 251
	}
	if level == 1 && variant == "RSDP-G" && schemeType == "fast" {
		params.Off = []int{0, 0, 0, 0, 2, 6, 6, 38, 38}
		params.NPL = []int{1, 2, 4, 8, 14, 24, 48, 64, 128}
		params.LPL = []int{0, 0, 0, 1, 2, 0, 16, 0, 128}
		params.LSI = []int{165, 85, 27, 14}
		params.NCL = []int{128, 16, 2, 1}
		params.TN = 76
	} else if level == 1 && variant == "RSDP-G" && schemeType == "balanced" {
		params.Off = []int{0, 0, 0, 0, 0, 0, 0, 0, 0}
		params.NPL = []int{1, 2, 4, 8, 16, 32, 64, 128, 256}
		params.LPL = []int{0, 0, 0, 0, 0, 0, 0, 0, 256}
		params.LSI = []int{255}
		params.NCL = []int{256}
		params.TN = 101
	} else if level == 1 && variant == "RSDP-G" && schemeType == "small" {
		params.Off = []int{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
		params.NPL = []int{1, 2, 4, 8, 16, 32, 64, 128, 256, 512}
		params.LPL = []int{0, 0, 0, 0, 0, 0, 0, 0, 0, 512}
		params.LSI = []int{511}
		params.NCL = []int{512}
		params.TN = 117
	} else if level == 3 && variant == "RSDP-G" && schemeType == "fast" {
		params.Off = []int{0, 0, 0, 0, 0, 0, 0, 0, 64}
		params.NPL = []int{1, 2, 4, 8, 16, 32, 64, 128, 192}
		params.LPL = []int{0, 0, 0, 0, 0, 0, 0, 32, 192}
		params.LSI = []int{255, 223}
		params.NCL = []int{192, 32}
		params.TN = 119
	} else if level == 3 && variant == "RSDP-G" && schemeType == "balanced" {
		params.Off = []int{0, 0, 0, 0, 0, 8, 24, 24, 24, 24}
		params.NPL = []int{1, 2, 4, 8, 16, 24, 32, 64, 128, 256}
		params.LPL = []int{0, 0, 0, 0, 4, 8, 0, 0, 0, 256}
		params.LSI = []int{279, 47, 27}
		params.NCL = []int{256, 8, 4}
		params.TN = 138
	} else if level == 3 && variant == "RSDP-G" && schemeType == "small" {
		params.Off = []int{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
		params.NPL = []int{1, 2, 4, 8, 16, 32, 64, 128, 256, 512}
		params.LPL = []int{0, 0, 0, 0, 0, 0, 0, 0, 0, 512}
		params.LSI = []int{511}
		params.NCL = []int{512}
		params.TN = 165
	} else if level == 5 && variant == "RSDP-G" && schemeType == "fast" {
		params.Off = []int{0, 0, 0, 0, 0, 0, 8, 24, 88, 88}
		params.NPL = []int{1, 2, 4, 8, 16, 32, 56, 96, 128, 256}
		params.LPL = []int{0, 0, 0, 0, 0, 4, 8, 32, 0, 256}
		params.LSI = []int{343, 183, 111, 59}
		params.NCL = []int{256, 32, 8, 4}
		params.TN = 153
	} else if level == 5 && variant == "RSDP-G" && schemeType == "balanced" {
		params.Off = []int{0, 0, 0, 0, 0, 0, 8, 8, 8, 200}
		params.NPL = []int{1, 2, 4, 8, 16, 32, 56, 112, 224, 256}
		params.LPL = []int{0, 0, 0, 0, 0, 4, 0, 0, 96, 256}
		params.LSI = []int{455, 359, 59}
		params.NCL = []int{256, 96, 4}
		params.TN = 185
	} else if level == 5 && variant == "RSDP-G" && schemeType == "small" {
		params.Off = []int{0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 260}
		params.NPL = []int{1, 2, 4, 8, 12, 24, 48, 96, 192, 384, 512}
		params.LPL = []int{0, 0, 0, 2, 0, 0, 0, 0, 0, 128, 512}
		params.LSI = []int{771, 643, 13}
		params.NCL = []int{512, 128, 2}
		params.TN = 220
	}
	return params
}

func LeftChild(node_index int) int {
	return 2*node_index + 1
}
func Parent(node_index int) int {
	if node_index%2 == 1 {
		return (node_index - 1) / 2
	}
	return (node_index - 2) / 2

}
func ParentIndex(index int) []byte {
	data := make([]byte, 2)

	// Convert to little-endian
	binary.LittleEndian.PutUint16(data, uint16(index))
	return data
}

func Leaves(tree [][]byte, t int, LSI, NCL []int) [][]byte {
	result := make([][]byte, t)
	for i := 0; i < len(LSI); i++ {
		index := LSI[i]
		for j := 0; j < NCL[i]; j++ {
			result = append(result, tree[index+j])
		}
	}
	return result
}
func SeedLeaves(schemeType string, seed, salt []byte, proto_params common.ProtocolData, tree_params TreeParams) ([][]byte, error) {
	if schemeType == "balanced" || schemeType == "small" {
		T := make([][]byte, tree_params.TN)
		T[0] = seed
		start_node := 0
		for level := 0; level <= int(math.Ceil(math.Log2(float64(proto_params.T)))-1); level++ {
			for i := 0; i <= tree_params.NPL[level]-tree_params.LPL[level]-1; i++ {
				parent := start_node + i
				left_child := LeftChild(parent) - tree_params.Off[level]
				right_child := left_child + 1
				// Expand parent seed, salt and parent index
				hash := make([]byte, (2*proto_params.Lambda)/8)
				sha3.ShakeSum128(hash, append(append(T[parent], salt...), ParentIndex(parent)...))
				T[left_child] = hash[:proto_params.Lambda/8]
				T[right_child] = hash[proto_params.Lambda/8:]
			}
			start_node = start_node + tree_params.NPL[level]
		}
		return Leaves(T, proto_params.T, tree_params.LSI, tree_params.NCL), nil
	} else if schemeType == "fast" {
		T := make([][]byte, tree_params.TN)
		T[0] = seed
		hash := make([]byte, (4*proto_params.Lambda)/8)
		sha3.ShakeSum128(hash, append(append(T[0], salt...), ParentIndex(0)...))
		for i := 1; i <= 4; i++ {
			T[i] = hash[(i-1)*proto_params.Lambda/8 : i*proto_params.Lambda/8]
		}
		children := make([]int, 4)
		if proto_params.T%4 == 0 {
			for i := 0; i < len(children); i++ {
				children[i] = int(math.Floor(float64(proto_params.T) / 4))
			}
		} else if proto_params.T%4 == 1 {
			for i := 0; i < len(children); i++ {
				if i == 0 {
					children[i] = int(math.Floor(float64(proto_params.T)/4)) + 1
				} else {
					children[i] = int(math.Floor(float64(proto_params.T) / 4))
				}
			}
		} else if proto_params.T%4 == 2 {
			for i := 0; i < len(children); i++ {
				if i == 0 || i == 1 {
					children[i] = int(math.Floor(float64(proto_params.T)/4)) + 1
				} else {
					children[i] = int(math.Floor(float64(proto_params.T) / 4))
				}
			}
		} else if proto_params.T%4 == 3 {
			for i := 0; i < len(children); i++ {
				if i == 0 || i == 1 || i == 2 {
					children[i] = int(math.Floor(float64(proto_params.T)/4)) + 1
				} else {
					children[i] = int(math.Floor(float64(proto_params.T) / 4))
				}
			}
		}
		for i := 0; i <= 3; i++ {
			hash := make([]byte, (children[i]*proto_params.Lambda)/8)
			sha3.ShakeSum128(hash, append(append(T[i+1], salt...), ParentIndex(i+1)...))
		}
		return T[5 : proto_params.T+4], nil
	} else {
		return nil, fmt.Errorf("Scheme type not supported only balanced, small and fast are supported")
	}
}

func ComputeNodesToPublish(T [][]byte, LSI, NCL []int, chall_2 []bool, TN int) [][]byte {
	result := make([]bool, TN)
	ctr := 0
	for i := 0; i < len(LSI); i++ {
		for j := 0; j < NCL[i]; j++ {
			if chall_2[ctr] {
				result[LSI[i]+j] = chall_2[ctr]
			}
			ctr++
		}
	}
	for i := TN - 1; i >= 0; i-- {
		if result[LeftChild(i)] && result[LeftChild(i)+1] {
			result[i] = true
			result[LeftChild(i)] = false
			result[LeftChild(i)+1] = false
		}
	}
	var path [][]byte
	for i := 0; i < TN; i++ {
		if result[i] {
			path = append(path, T[i])
		}
	}
	return path
}

func SeedPath(schemeType string, seed, salt []byte, chall_2 []bool, proto_params common.ProtocolData, tree_params TreeParams) ([][]byte, error) {
	if schemeType == "balanced" || schemeType == "small" {
		T, err := SeedLeaves(schemeType, seed, salt, proto_params, tree_params)
		if err != nil {
			return nil, err
		}
		path := ComputeNodesToPublish(T, tree_params.LSI, tree_params.NCL, chall_2, tree_params.TN)
		return path, nil
	} else if schemeType == "fast" {
		leaves, err := SeedLeaves(schemeType, seed, salt, proto_params, tree_params)
		if err != nil {
			return nil, err
		}
		result := make([][]byte, tree_params.TN)
		for i := 0; i < len(chall_2); i++ {
			if chall_2[i] == true {
				result = append(result, leaves[i])
			}
		}
		return result, nil
	} else {
		return nil, fmt.Errorf("Scheme type not supported only balanced, small and fast are supported")
	}
}

/*

type SeedTree struct {
	Root       *Node
	Nodes      map[int]*Node // Store all nodes by their index
	LeafNodes  []*Node       // Store leaf nodes separately
	DataLength int
}

type Node struct {
	Left   *Node
	Right  *Node
	Data   []byte
	IsLeaf bool
	Parent *Node
	Index  int
}
// Implement String method for Node to pretty print the node structure
func (n *Node) String() string {
	var sb strings.Builder
	printNode(n, &sb, "")
	return sb.String()
}

// Helper function to recursively print nodes
func printNode(node *Node, sb *strings.Builder, prefix string) {
	if node == nil {
		return
	}

	// Print the current node
	sb.WriteString(fmt.Sprintf("%s- Node Index: %d, IsLeaf: %t, DataByte: %d\n", prefix, node.Index, node.IsLeaf, node.Data[0]))

	// Recursively print left and right children
	if node.Left != nil || node.Right != nil {
		if node.Left != nil {
			printNode(node.Left, sb, prefix+"|   ")
		} else {
			sb.WriteString(fmt.Sprintf("%s|   - No Left Child\n", prefix))
		}
		if node.Right != nil {
			printNode(node.Right, sb, prefix+"|   ")
		} else {
			sb.WriteString(fmt.Sprintf("%s|   - No Right Child\n", prefix))
		}
	}
}

// Implement String method for SeedTree to pretty print the entire tree structure
func (st *SeedTree) String() string {
	var sb strings.Builder
	if st.Root != nil {
		sb.WriteString("SeedTree Structure:\n")
		sb.WriteString(st.Root.String()) // Print the tree starting from root
	}
	return sb.String()
}

func NewSeedTree(mseed, salt []byte, t int) *SeedTree {
	tree := &SeedTree{
		Nodes: make(map[int]*Node),
	}

	// Calculate tree depth needed for t leaves
	treeDepth := int(math.Ceil(math.Log2(float64(t))))

	// Create root node
	var rootData []byte
	rootData = append(append(mseed, salt...), byte(0))
	tree.Root = &Node{
		Data:   rootData,
		IsLeaf: false,
		Index:  0,
	}
	tree.DataLength = len(rootData) - 1
	tree.Nodes[0] = tree.Root

	// Build the tree
	tree.buildTree(tree.Root, salt, 0, treeDepth, 0)

	// Collect leaves
	tree.collectLeaves(t)

	return tree
}

func (st *SeedTree) generateChildData(parentData, salt []byte, index int) []byte {
	output := make([]byte, st.DataLength)

	var input []byte
	input = append(append(parentData, salt...), IntToBytes(index)...)
	sha3.ShakeSum128(output, input)
	return output
}

func (st *SeedTree) buildTree(parent *Node, salt []byte, currentDepth, maxDepth, index int) {
	if parent == nil {
		return
	}

	if currentDepth == maxDepth {
		parent.IsLeaf = true
		return
	}

	// Create left child
	leftIdx := 2*index + 1
	leftData := st.generateChildData(parent.Data, salt, leftIdx)
	parent.Left = &Node{
		Data:   leftData,
		IsLeaf: false,
		Parent: parent,
		Index:  leftIdx,
	}
	st.Nodes[leftIdx] = parent.Left

	// Create right child
	rightIdx := 2*index + 2
	rightData := st.generateChildData(parent.Data, salt, rightIdx)
	parent.Right = &Node{
		Data:   rightData,
		IsLeaf: false,
		Parent: parent,
		Index:  rightIdx,
	}
	st.Nodes[rightIdx] = parent.Right

	// Recursively build subtrees
	st.buildTree(parent.Left, salt, currentDepth+1, maxDepth, leftIdx)
	st.buildTree(parent.Right, salt, currentDepth+1, maxDepth, rightIdx)
}

func (st *SeedTree) collectLeaves(t int) {
	st.LeafNodes = make([]*Node, 0, t)
	remainingLeaves := t
	st.collectLeavesRecursive(st.Root, &remainingLeaves)
	st.LeafNodes = st.LeafNodes[:t]
}

func (st *SeedTree) collectLeavesRecursive(node *Node, remainingLeaves *int) {
	if node == nil || *remainingLeaves <= 0 {
		return
	}

	if node.IsLeaf {
		if *remainingLeaves > 0 {
			st.LeafNodes = append(st.LeafNodes, node)
			*remainingLeaves--
		}
		return
	}

	st.collectLeavesRecursive(node.Left, remainingLeaves)
	st.collectLeavesRecursive(node.Right, remainingLeaves)
}

// Helper function
func IntToBytes(n int) []byte {
	bytes := make([]byte, 2)
	binary.BigEndian.PutUint16(bytes, uint16(n))
	return bytes
}

func SeedTreeLeaves(t int, mseed, salt []byte, useSalt bool) []*Node {
	tree := NewSeedTree(mseed, salt, t)
	return tree.LeafNodes[:t]
}

func contains(nodes []*Node, target *Node) bool {
	for _, node := range nodes {
		if node == target {
			return true
		}
	}
	return false
}
func remove(nodes []*Node, target *Node) []*Node {
	for i, node := range nodes {
		if node == target {
			// Remove the node by slicing around it
			return append(nodes[:i], nodes[i+1:]...)
		}
	}
	return nodes
}

func SeedTreePaths(salt, mseed []byte, b []bool, t int) ([]*Node, *SeedTree) {
	tree := NewSeedTree(mseed, salt, t)
	reveal_nodes := make([]*Node, 0)
	for i := range b {
		if b[i] == true {
			reveal_nodes = append(reveal_nodes, tree.LeafNodes[i])
		}
	}
	// Run through tree.Nodes in reverse, and check if both children are in reveal_leaves, if they are replace 2 children with 1 parent
	for i := len(tree.Nodes) - 1; i >= 0; i-- {
		node := tree.Nodes[i]
		if node.Left != nil && node.Right != nil {
			if contains(reveal_nodes, node.Left) && contains(reveal_nodes, node.Right) {
				reveal_nodes = remove(reveal_nodes, node.Left)
				reveal_nodes = remove(reveal_nodes, node.Right)
				reveal_nodes = append(reveal_nodes, node)
			}
		}
	}
	return reveal_nodes[:t], tree
}
*/
